<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>FireRedASR API &#x5b8c;&#x6574;&#x6587;&#x6863;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="fireredasr-api-完整文档">FireRedASR API 完整文档</h1>
<p><strong>版本: 1.3.1</strong></p>
<h2 id="概述">概述</h2>
<p>本文档详细说明了如何使用 FireRedASR API 来进行高精度的语音识别。该API服务提供了一个统一的端点，支持处理单个或批量的音频文件，并允许对底层ASR模型及解码参数进行全面、灵活的配置。
服务器端对模型路径进行了统一管理，调用者只需通过 <code>asr_type</code> 参数选择 <code>aed</code> 或 <code>llm</code> 模型，无需关心其物理存储位置。</p>
<h2 id="端点-post-transcribe">端点: <code>POST /transcribe/</code></h2>
<p>这是执行语音转文字的核心API端点。</p>
<h3 id="并发处理机制-重要"><strong>并发处理机制 (重要)</strong></h3>
<p>为了保证服务的稳定性和避免因资源竞争（尤其是GPU显存）导致的崩溃，本API服务器内部采用了 <strong>队列处理机制</strong>。</p>
<ul>
<li>服务器可以 <strong>同时接收</strong> 多个并发请求。</li>
<li>所有接收到的请求任务会进入一个 <strong>先进先出（FIFO）的队列</strong>。</li>
<li>服务器会 <strong>按顺序、逐一</strong> 从队列中取出任务进行处理。</li>
<li>只有当前任务完全处理结束后，下一个任务才会开始。
这意味着，对于API使用者来说，即使同时发送多个请求，它们的处理也是顺序的。在高负载情况下，后续请求的等待时间可能会增加，但这种设计确保了每个任务都能在资源充足的环境下被正确、稳定地执行。</li>
</ul>
<h3 id="健康检查端点-get-health"><strong>健康检查端点: <code>GET /health</code></strong></h3>
<p>用于检测服务是否正常运行。</p>
<ul>
<li><strong>响应</strong>: <code>{&quot;status&quot;: &quot;healthy&quot;}</code></li>
<li><strong>状态码</strong>: 200 OK</li>
</ul>
<h3 id="请求格式">请求格式</h3>
<p>请求必须采用 <code>multipart/form-data</code> 格式。您可以通过以下两种方式之一提供音频：</p>
<ol>
<li><strong><code>files</code></strong>: 直接上传一个或多个音频文件。单个请求中上传的所有文件会被视为一个处理批次。</li>
<li><strong><code>paths</code></strong>: 提供一个以逗号分隔的字符串，内容是位于服务器上的音频文件的绝对路径。</li>
</ol>
<p><strong>注意:</strong> 在单次请求中，您必须提供 <code>files</code> 或 <code>paths</code> 之一，但不能同时提供。</p>
<h3 id="表单参数-form-parameters">表单参数 (Form Parameters)</h3>
<p>所有参数都以表单字段（Form Fields）的形式发送。</p>
<h4 id="模型加载参数"><strong>模型加载参数</strong></h4>
<p>这些参数决定了后端加载哪个模型以及如何配置它。当这些参数发生变化时，服务器会自动重新加载模型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">可选值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>asr_type</code></td>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>llm</code></td>
<td style="text-align:left"><code>aed</code>, <code>llm</code></td>
<td style="text-align:left">模型架构。</td>
</tr>
<tr>
<td style="text-align:left"><code>asr_device</code></td>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>cuda:0</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">ASR编码器所用的设备 (例如 <code>cuda:0</code>, <code>cpu</code>)。</td>
</tr>
<tr>
<td style="text-align:left"><code>llm_device</code></td>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>cuda:1</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">LLM部分所用的设备 (例如 <code>cuda:1</code>, <code>cpu</code>)。仅在 <code>asr_type=llm</code> 时使用。</td>
</tr>
<tr>
<td style="text-align:left"><code>llm_dtype</code></td>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>bf16</code></td>
<td style="text-align:left"><code>fp32</code>, <code>fp16</code>, <code>bf16</code></td>
<td style="text-align:left">LLM推理时的数据类型。</td>
</tr>
<tr>
<td style="text-align:left"><code>use_flash_attn</code></td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left"><code>true</code>, <code>false</code></td>
<td style="text-align:left">设置为 <code>true</code> 以启用LLM的 Flash Attention 2。</td>
</tr>
</tbody>
</table>
<h4 id="转录参数"><strong>转录参数</strong></h4>
<p>这些参数控制解码过程的行为，可以在不重新加载模型的情况下动态调整。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>batch_size</code></td>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">推理时的内部批处理大小，用于控制显存（VRAM）使用量。</td>
</tr>
<tr>
<td style="text-align:left"><code>beam_size</code></td>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>3</code></td>
<td style="text-align:left">解码过程中使用的束搜索（Beam Search）大小。</td>
</tr>
<tr>
<td style="text-align:left"><code>decode_max_len</code></td>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">生成文本序列的最大长度。<code>0</code> 表示不设限制。</td>
</tr>
<tr>
<td style="text-align:left"><code>nbest</code></td>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left"><strong>(AED专用)</strong> 返回的最佳假设的数量。</td>
</tr>
<tr>
<td style="text-align:left"><code>softmax_smoothing</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>1.0</code></td>
<td style="text-align:left"><strong>(AED专用)</strong> Softmax平滑因子。</td>
</tr>
<tr>
<td style="text-align:left"><code>aed_length_penalty</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>0.6</code></td>
<td style="text-align:left"><strong>(AED专用)</strong> 对较长序列的惩罚系数。</td>
</tr>
<tr>
<td style="text-align:left"><code>eos_penalty</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>1.0</code></td>
<td style="text-align:left"><strong>(AED专用)</strong> 对句末符（EOS）的惩罚系数。</td>
</tr>
<tr>
<td style="text-align:left"><code>decode_min_len</code></td>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left"><strong>(LLM专用)</strong> 生成文本序列的最小长度。</td>
</tr>
<tr>
<td style="text-align:left"><code>repetition_penalty</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>3.0</code></td>
<td style="text-align:left"><strong>(LLM专用)</strong> 用于抑制重复词语的惩罚系数。</td>
</tr>
<tr>
<td style="text-align:left"><code>llm_length_penalty</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>1.0</code></td>
<td style="text-align:left"><strong>(LLM专用)</strong> 对较长序列的惩罚系数。</td>
</tr>
<tr>
<td style="text-align:left"><code>temperature</code></td>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>1.0</code></td>
<td style="text-align:left"><strong>(LLM专用)</strong> 采样温度。<code>1.0</code> 表示不改变。</td>
</tr>
</tbody>
</table>
<h3 id="响应格式">响应格式</h3>
<h4 id="成功响应-200-ok"><strong>成功响应 (200 OK)</strong></h4>
<p>API会返回一个JSON数组，其中每个对象对应一个已转录的音频文件。</p>
<ul>
<li><strong><code>uttid</code></strong>: 唯一标识符，从文件名派生而来。</li>
<li><strong><code>text</code></strong>: 模型识别出的文本结果。</li>
<li><strong><code>wav</code></strong>: 被处理的音频文件路径。如果是文件上传，这里会显示其在服务器上的临时路径。</li>
<li><strong><code>rtf</code></strong>: 实时率（Real-Time Factor），表示处理时长与音频时长的比值，越小越好。</li>
</ul>
<p><strong>响应示例:</strong></p>
<pre><code class="language-json"><span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;uttid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio_chunk_01&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这里是第一段音频的转录文本内容&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;wav&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Temp/tmp_xyz_audio_chunk_01.wav&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;rtf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.1588&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;uttid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio_chunk_02&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是第二段音频的识别结果&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;wav&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Temp/tmp_abc_audio_chunk_02.wav&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;rtf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.1601&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<h4 id="错误响应"><strong>错误响应</strong></h4>
<ul>
<li><strong><code>400 Bad Request</code></strong>: 如果请求中既未提供 <code>files</code> 也未提供 <code>paths</code>，或服务器未配置请求的 <code>asr_type</code>，则返回此错误。</li>
<li><strong><code>422 Unprocessable Entity</code></strong>: 如果任何表单参数未能通过验证（例如，<code>asr_type</code> 不是 <code>aed</code> 或 <code>llm</code>，或 <code>batch_size</code> 不是正整数），则返回此错误。响应体中将包含详细的验证错误信息。</li>
<li><strong><code>500 Internal Server Error</code></strong>: 如果服务器端配置的模型路径不存在，则返回此错误。</li>
</ul>
<h2 id="完整请求示例">完整请求示例</h2>
<p>以下示例展示了如何通过 <code>curl</code> 和 Python <code>requests</code> 库调用此API。</p>
<h3 id="示例1上传单个文件使用默认llm模型">示例1：上传单个文件，使用默认LLM模型</h3>
<h4 id="使用-curl"><strong>使用 <code>curl</code></strong></h4>
<pre><code class="language-bash"><span class="hljs-comment"># -F &quot;files=@/path/to/your/audio.wav&quot; 表示上传一个文件</span>
<span class="hljs-comment"># 其他参数使用默认值</span>
curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span> \
  -F <span class="hljs-string">&quot;files=@/data/my_audio/meeting_part_1.wav&quot;</span> \
  -H <span class="hljs-string">&quot;accept: application/json&quot;</span>
</code></pre>
<h4 id="使用-python-requests"><strong>使用 Python <code>requests</code></strong></h4>
<pre><code class="language-python"><span class="hljs-keyword">import</span> requests

<span class="hljs-comment"># API的URL</span>
url = <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span>

<span class="hljs-comment"># 要上传的音频文件路径</span>
file_path = <span class="hljs-string">&quot;/data/my_audio/meeting_part_1.wav&quot;</span>

<span class="hljs-comment"># &#x27;rb&#x27; 表示以二进制读取模式打开文件</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-comment"># 准备文件部分，&#x27;files&#x27; 键需要与API中定义的参数名匹配</span>
    files = {<span class="hljs-string">&#x27;files&#x27;</span>: (file_path, f, <span class="hljs-string">&#x27;audio/wav&#x27;</span>)}
    
    <span class="hljs-comment"># 发送POST请求</span>
    response = requests.post(url, files=files)

<span class="hljs-comment"># 检查响应</span>
<span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功!&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;识别结果:&quot;</span>, response.json())
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码: <span class="hljs-subst">{response.status_code}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;错误详情:&quot;</span>, response.text)
</code></pre>
<h3 id="示例2上传多个文件使用aed模型并自定义参数">示例2：上传多个文件，使用AED模型并自定义参数</h3>
<h4 id="使用-curl-1"><strong>使用 <code>curl</code></strong></h4>
<pre><code class="language-bash"><span class="hljs-comment"># 多次使用 -F &quot;files=@...&quot; 来上传多个文件</span>
<span class="hljs-comment"># 同时通过 -F 传递其他自定义参数</span>
<span class="hljs-comment"># 注意：不再需要传递 model_dir</span>
curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span> \
  -H <span class="hljs-string">&quot;accept: application/json&quot;</span> \
  -F <span class="hljs-string">&quot;files=@/audios/chunk_001.wav&quot;</span> \
  -F <span class="hljs-string">&quot;files=@/audios/chunk_002.wav&quot;</span> \
  -F <span class="hljs-string">&quot;asr_type=aed&quot;</span> \
  -F <span class="hljs-string">&quot;batch_size=2&quot;</span> \
  -F <span class="hljs-string">&quot;beam_size=5&quot;</span> \
  -F <span class="hljs-string">&quot;aed_length_penalty=0.8&quot;</span>
</code></pre>
<h4 id="使用-python-requests-1"><strong>使用 Python <code>requests</code></strong></h4>
<pre><code class="language-python"><span class="hljs-keyword">import</span> requests

url = <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span>

<span class="hljs-comment"># 要上传的多个文件路径</span>
file_paths = [<span class="hljs-string">&quot;/audios/chunk_001.wav&quot;</span>, <span class="hljs-string">&quot;/audios/chunk_002.wav&quot;</span>]

<span class="hljs-comment"># 准备文件列表</span>
<span class="hljs-comment"># 对于多个文件，files参数需要是一个元组列表</span>
files_list = [
    (<span class="hljs-string">&#x27;files&#x27;</span>, (path, <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;rb&#x27;</span>), <span class="hljs-string">&#x27;audio/wav&#x27;</span>)) <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> file_paths
]

<span class="hljs-comment"># 准备其他表单参数</span>
<span class="hljs-comment"># 注意：不再需要传递 model_dir</span>
payload = {
    <span class="hljs-string">&#x27;asr_type&#x27;</span>: <span class="hljs-string">&#x27;aed&#x27;</span>,
    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">&#x27;beam_size&#x27;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&#x27;aed_length_penalty&#x27;</span>: <span class="hljs-number">0.8</span>
}

<span class="hljs-comment"># 发送请求，同时传递文件和数据</span>
response = requests.post(url, files=files_list, data=payload)

<span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功!&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;识别结果:&quot;</span>, response.json())
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码: <span class="hljs-subst">{response.status_code}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;错误详情:&quot;</span>, response.text)
</code></pre>
<h3 id="示例3指定服务器上的多个文件路径">示例3：指定服务器上的多个文件路径</h3>
<h4 id="使用-curl-2"><strong>使用 <code>curl</code></strong></h4>
<pre><code class="language-bash"><span class="hljs-comment"># -F &quot;paths=...&quot; 传递一个逗号分隔的路径字符串</span>
curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span> \
  -H <span class="hljs-string">&quot;accept: application/json&quot;</span> \
  -F <span class="hljs-string">&quot;paths=/server/audio/file_a.wav,/server/audio/file_b.wav&quot;</span> \
  -F <span class="hljs-string">&quot;batch_size=2&quot;</span>
</code></pre>
<h4 id="使用-python-requests-2"><strong>使用 Python <code>requests</code></strong></h4>
<pre><code class="language-python"><span class="hljs-keyword">import</span> requests

url = <span class="hljs-string">&quot;http://127.0.0.1:8000/transcribe/&quot;</span>

<span class="hljs-comment"># 服务器上的文件路径，用逗号连接</span>
server_paths = <span class="hljs-string">&quot;/server/audio/file_a.wav,/server/audio/file_b.wav&quot;</span>

<span class="hljs-comment"># 准备数据负载</span>
payload = {
    <span class="hljs-string">&#x27;paths&#x27;</span>: server_paths,
    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">2</span>
}

<span class="hljs-comment"># 此时不需要files参数，只需要data参数</span>
response = requests.post(url, data=payload)

<span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功!&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;识别结果:&quot;</span>, response.json())
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败，状态码: <span class="hljs-subst">{response.status_code}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;错误详情:&quot;</span>, response.text)
</code></pre>

            
            
        </body>
        </html>